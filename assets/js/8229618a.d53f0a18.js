"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[328],{3905:function(e,t,a){a.d(t,{Zo:function(){return m},kt:function(){return d}});var r=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},o=Object.keys(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var c=r.createContext({}),l=function(e){var t=r.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},m=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,c=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),p=l(a),d=n,h=p["".concat(c,".").concat(d)]||p[d]||u[d]||o;return a?r.createElement(h,s(s({ref:t},m),{},{components:a})):r.createElement(h,s({ref:t},m))}));function d(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,s=new Array(o);s[0]=p;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:n,s[1]=i;for(var l=2;l<o;l++)s[l]=a[l];return r.createElement.apply(null,s)}return r.createElement.apply(null,a)}p.displayName="MDXCreateElement"},4247:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return i},metadata:function(){return c},toc:function(){return l},default:function(){return u}});var r=a(7462),n=a(3366),o=(a(7294),a(3905)),s=["components"],i={sidebar_label:"Actor model",sidebar_position:3},c={unversionedId:"gear/actor-model",id:"gear/actor-model",isDocsHomePage:!1,title:"Gear Actor model for communications",description:'In the concurrent computing systems a "Message-passing communication" approach implies programs communication via messages exchanging. It has advantages over "Shared memory communication". Message passing is easier to understand than shared memory concurrency. It is usually considered a more robust, has better performance characteristics than shared memory.',source:"@site/docs/gear/actor-model.md",sourceDirName:"gear",slug:"/gear/actor-model",permalink:"/gear/actor-model",editUrl:"https://github.com/gear-tech/wiki/edit/master/docs/gear/actor-model.md",version:"current",sidebar_label:"Actor model",sidebarPosition:3,frontMatter:{sidebar_label:"Actor model",sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"State transition",permalink:"/gear/gear-state/state-transition"},next:{title:"Memory parallelism",permalink:"/gear/memory-parallelism"}},l=[{value:"Actor",id:"actor",children:[]},{value:"Async/await support",id:"asyncawait-support",children:[]}],m={toc:l};function u(e){var t=e.components,a=(0,n.Z)(e,s);return(0,o.kt)("wrapper",(0,r.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,'In the concurrent computing systems a "Message-passing communication" approach implies programs communication via messages exchanging. It has advantages over "Shared memory communication". Message passing is easier to understand than shared memory concurrency. It is usually considered a more robust, has better performance characteristics than shared memory. '),(0,o.kt)("p",null,"For inter-process communications, Gear uses the Actor model approach - one of the plenty mathematical theories describing message-passing systems. The popularity of the Actor model has increased and it has been used in many new programming languages. The principle of the Actor model is that programs never share any state and just exchange messages between each other."),(0,o.kt)("p",null,"In the Actor model, a system consists of simultaneously functioning objects that communicate with each other exclusively by messaging. While an ordinary Actor model does not guarantee a message ordering, Gear provides some additional guarantees that the order of messages between two particular programs is preserved. "),(0,o.kt)("p",null,"The Actor model guarantees:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"High scalability "),(0,o.kt)("li",{parentName:"ul"},"\u041digh fault tolerance ")),(0,o.kt)("h2",{id:"actor"},"Actor"),(0,o.kt)("p",null,"An Actor in the Actor model, is an atomic computational unit that can send and receive messages. In case of Gear, an actor is a program (smart-contract) or a user that sends messages to a program. Every actor has an internal private state and a mailbox. Communication is asynchronous, messages are popped out from the mailbox and allocated to message provessing streams where processed in cycles."),(0,o.kt)("p",null,"When an actor receives and processes a message, the response can be the following:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Send a message to another actor"),(0,o.kt)("li",{parentName:"ul"},"Create another actor"),(0,o.kt)("li",{parentName:"ul"},"Change its own internal state")),(0,o.kt)("p",null,"Actors are independent, they never share any state and just exchange messages with each other. "),(0,o.kt)("p",null,"Using the Actor model approach gives a way to implement Actor-based concurrency inside programs (smart-contracts) logic. It can utilize various language constructs for asynchronous programming (Futures and async-await in Rust)."),(0,o.kt)("h2",{id:"asyncawait-support"},"Async/await support"),(0,o.kt)("p",null,"Unlike classes, actors allow only one task to access their mutable state at a time, which makes it safe for code in multiple tasks to interact with the same instance of an actor."),(0,o.kt)("p",null,"Asynchronous functions significantly streamline concurrency management, but they do not handle the possibility of deadlocks or state corruption. To avoid deadlocks or state corruption, async functions should avoid calling functions that may block their thread. To achieve it, they use an await expression."),(0,o.kt)("p",null,"Currently, the lack of normal support of async/await pattern in the typical smart contracts code brings a lot of problems for smart contract developers. Actually, achieving better control in a smart contract program flow is actually more or less possible by adding handmade functions (in Solidity smart contracts). But the problem with many functions in a contract is that one can easily get confused - which function can be called at which stage in the contract's lifetime."),(0,o.kt)("p",null,"Gear natively provides arbitrary async/await syntax for any programs. It greatly simplifies development and testing and reduces the likelihood of errors in smart contract development. Gear API also allows to use synchronous messages by simply not using await expression if the logic of the program requires it."))}u.isMDXComponent=!0}}]);